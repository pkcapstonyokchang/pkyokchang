/*
 * 스마트 욕창 방지 매트리스 - 안정화 후 측정 모드 자동 전환
 *
 * [동작 순서]
 * 1. 제어 모드: 2.93 ~ 3.33 kPa 유지를 위해 펌프/밸브 작동.
 * 2. 안정화 감지: 5초 동안 아무 동작도 안 하면(안정 상태) -> 측정 모드로 전환.
 * 3. 측정 모드: 모든 구동 정지. 오직 압력 변화만 실시간 측정.
 */

#include <Wire.h>
#include <XGZP6897D.h>

// --- 1. 설정값 ---
#define PUMP_ON_THRESHOLD   2.93
#define VENT_OPEN_THRESHOLD 3.33
#define VENT_CLOSE_THRESHOLD 3.20

#define STABLE_TIME_MS      5000  // 5초간 동작 없으면 다음 단계로

#define SENSOR_COUNT        3
#define AVG_COUNT           10
#define K 512 

XGZP6897D mysensor(K);

// --- 2. 핀 매핑 ---
const int PUMP_PIN = 2;
const uint8_t SENSOR_CHS[SENSOR_COUNT] = {5, 6, 7};
const int VALVE_PINS[SENSOR_COUNT]     = {34, 32, 30}; 

// --- 3. 변수 ---
float raw_pressures[SENSOR_COUNT];
float avg_pressures[SENSOR_COUNT];
float offsets_pa[SENSOR_COUNT] = {0.0}; 
float temperature_c;
float pressure_history[SENSOR_COUNT][AVG_COUNT]; 
int history_index = 0;

bool isVenting[SENSOR_COUNT] = {false}; 
unsigned long lastSensorReadTime = 0;

// [신규] 상태 변수
bool isMeasuringMode = false;       // true면 측정 모드 (제어 중단)
unsigned long lastActiveTime = 0;   // 마지막으로 펌프/밸브가 켜졌던 시간

// --- 함수 프로토타입 ---
void tcaSelect(uint8_t channel);
void setupAllSensors();
void readAllSensors();
void calculateAverage();
void controlLogic();
void printStatus();


void tcaSelect(uint8_t channel) {
  if (channel > 7) return;
  Wire.beginTransmission(0x70);
  Wire.write(1 << channel);
  Wire.endTransmission();
}

void setup() {
  Serial.begin(9600);
  Wire.begin();

  pinMode(PUMP_PIN, OUTPUT);
  for (int i = 0; i < SENSOR_COUNT; i++) {
    pinMode(VALVE_PINS[i], OUTPUT);
    digitalWrite(VALVE_PINS[i], LOW);
  }
  digitalWrite(PUMP_PIN, LOW);

  Serial.println("--- 스마트 압력 제어 & 측정 시스템 시작 ---");
  
  // 초기 배출
  Serial.println(">>> [초기화] 잔여 공기 배출 (10초)...");
  for(int i=0; i<SENSOR_COUNT; i++) digitalWrite(VALVE_PINS[i], HIGH);
  delay(10000);
  for(int i=0; i<SENSOR_COUNT; i++) digitalWrite(VALVE_PINS[i], LOW);

  setupAllSensors();
  
  lastActiveTime = millis(); // 타이머 시작
}

void loop() {
  if (millis() - lastSensorReadTime >= 100) {
    lastSensorReadTime = millis();
    
    readAllSensors();
    calculateAverage();
    
    // [모드 분기] 측정 모드냐? 제어 모드냐?
    if (isMeasuringMode) {
      // [B] 측정 모드: 제어 안 함, 값만 출력
      printStatus(); 
    } else {
      // [A] 제어 모드: 펌프/밸브 조절 + 안정화 감지
      controlLogic();
      checkStability(); // 5초 지났는지 확인
      printStatus();
    }
  }
}

// --- [신규] 안정화 확인 함수 ---
void checkStability() {
  unsigned long currentMillis = millis();
  
  // 5초(STABLE_TIME_MS) 동안 아무 일도 없었으면?
  if (currentMillis - lastActiveTime > STABLE_TIME_MS) {
    isMeasuringMode = true; // 측정 모드 진입!
    Serial.println("\n>>> [안정화 완료] 제어 중단 -> 측정 모드 진입!");
    Serial.println(">>> 이제 신체를 올려 압력 변화를 관찰하세요.\n");
    
    // 확실하게 모두 끄기
    digitalWrite(PUMP_PIN, LOW);
    for(int i=0; i<SENSOR_COUNT; i++) digitalWrite(VALVE_PINS[i], LOW);
  }
}

void calculateAverage() {
  for (int i = 0; i < SENSOR_COUNT; i++) {
    pressure_history[i][history_index] = raw_pressures[i];
  }
  history_index++;
  if (history_index >= AVG_COUNT) history_index = 0;

  for (int i = 0; i < SENSOR_COUNT; i++) {
    float sum = 0.0;
    for (int j = 0; j < AVG_COUNT; j++) sum += pressure_history[i][j];
    avg_pressures[i] = sum / AVG_COUNT;
  }
}

void controlLogic() {
  bool systemActive = false; // 이번 루프에 뭐라도 켜졌는지 확인

  // 1. 펌프 제어
  bool needInflation = false;
  for (int i = 0; i < SENSOR_COUNT; i++) {
    if (avg_pressures[i] < PUMP_ON_THRESHOLD) {
      needInflation = true;
      break; 
    }
  }

  if (needInflation) {
    digitalWrite(PUMP_PIN, HIGH); 
    systemActive = true; // 펌프 돔
  } else {
    digitalWrite(PUMP_PIN, LOW);  
  }

  // 2. 밸브 제어
  for (int i = 0; i < SENSOR_COUNT; i++) {
    float p = avg_pressures[i]; 

    if (p > VENT_OPEN_THRESHOLD) isVenting[i] = true; 
    else if (p < VENT_CLOSE_THRESHOLD) isVenting[i] = false; 
    
    if (isVenting[i]) {
      digitalWrite(VALVE_PINS[i], HIGH);
      systemActive = true; // 밸브 열림
    } else {
      digitalWrite(VALVE_PINS[i], LOW);
    }
  }
  
  // 이번 루프에 펌프나 밸브가 하나라도 작동했다면?
  if (systemActive) {
    lastActiveTime = millis(); // 타이머 리셋 (안정화 실패)
  }
}

void readAllSensors() {
  for (int i = 0; i < SENSOR_COUNT; i++) {
    tcaSelect(SENSOR_CHS[i]); 
    float p_pa;
    if (mysensor.readSensor(temperature_c, p_pa)) {
      raw_pressures[i] = (p_pa - offsets_pa[i]) / 1000.0;
    }
  }
}

void printStatus() {
  if (isMeasuringMode) Serial.print("[측정중] ");
  else Serial.print("[제어중] ");
  
  for (int i = 0; i < SENSOR_COUNT; i++) {
    Serial.print("S"); Serial.print(i+1);
    Serial.print(":"); Serial.print(avg_pressures[i], 2);
    
    if (!isMeasuringMode) { // 제어 중일 때만 밸브 상태 표시
      if (isVenting[i]) Serial.print("(Open) ");
      else Serial.print("       ");
    } else {
      Serial.print("       ");
    }
  }
  
  if (!isMeasuringMode) {
    Serial.print(digitalRead(PUMP_PIN) ? " [PUMP:ON]" : " [PUMP:OFF]");
    // 타이머 상태 표시 (몇 초째 안정인지)
    Serial.print(" 안정:");
    Serial.print((millis() - lastActiveTime)/1000);
    Serial.print("s");
  }
  Serial.println();
}

void setupAllSensors() {
  Serial.println("영점 잡는 중...");
  delay(1000);

  for (int i = 0; i < SENSOR_COUNT; i++) {
    tcaSelect(SENSOR_CHS[i]); 
    delay(10);
    if(mysensor.begin()) {
       float p;
       mysensor.readSensor(temperature_c, p);
       offsets_pa[i] = p;
       for(int j=0; j<AVG_COUNT; j++) pressure_history[i][j] = 0.0;
    } else {
       Serial.println("센서 연결 실패!");
    }
  }
  Serial.println("설정 완료.");
}
